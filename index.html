<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2026년 응급실 스케줄 생성기 (V7)</title>
    <!-- Tailwind CSS 로드 -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Inter 폰트 적용 */
        body {
            font-family: 'Inter', sans-serif;
        }
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
    </style>
</head>
<body class="bg-gray-100 p-4 md:p-8">
    <div class="max-w-7xl mx-auto bg-white p-6 md:p-8 rounded-xl shadow-lg">
        <h1 class="text-3xl font-bold text-blue-700 mb-4">2026년 응급실 스케줄 생성기 (V7)</h1>
        <p class="text-gray-700 mb-6">
            최종 버전: 4대 근무 유형(평일주간/야간, 휴일주간/야간)의 공정성을 최우선으로 고려합니다.<br>
            <strong>규칙:</strong> 1. 연속 근무 금지. 2. 최대한 공정하게 평일/휴일, 주간/야간 배분. 3. 파트너 순환
        </p>

        <!-- 통계 섹션 -->
        <div class="mb-6">
            <h2 class="text-2xl font-semibold text-gray-800 mb-3">의사별 근무 통계 (4대 유형)</h2>
            <div id="stats" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-6 gap-4">
                <!-- 통계 데이터가 여기에 동적으로 삽입됩니다. -->
            </div>
        </div>

        <!-- 스케줄 테이블 섹션 -->
        <div>
            <div class="flex justify-between items-center mb-3">
                <h2 class="text-2xl font-semibold text-gray-800">2026년 스케줄 표 (휴일 <span class="text-red-100 bg-red-500 px-1 rounded">배경</span>)</h2>
                <!-- CSV 내보내기 버튼 -->
                <button id="export-csv-btn" class="bg-green-600 text-white font-semibold px-4 py-2 rounded-lg shadow-md hover:bg-green-700 transition duration-200">
                    CSV로 내보내기
                </button>
            </div>
            <div class="overflow-x-auto rounded-lg border border-gray-200" style="max-height: 600px;">
                <table class="min-w-full divide-y divide-gray-200">
                    <thead class="bg-gray-50 sticky top-0">
                        <tr>
                            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">날짜</th>
                            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">요일</th>
                            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">주간 (Day)</th>
                            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">야간 (Night)</th>
                        </tr>
                    </thead>
                    <tbody id="schedule-body" class="bg-white divide-y divide-gray-200">
                        <!-- 스케줄 데이터가 여기에 동적으로 삽입됩니다. -->
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <script>
        let generatedSchedule = [];
        const doctorsList = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L'];
        const year = 2026;

        // [V5] 2026년 대한민국 공휴일 (주말 제외)
        const publicHolidays = new Set([
            '2026-01-01', // 신정
            '2026-02-16', // 설날 연휴
            '2026-02-17', // 설날
            '2026-02-18', // 설날 연휴
            '2026-03-02', // 삼일절 (대체)
            '2026-05-05', // 어린이날
            '2026-05-25', // 부처님오신날 (대체)
            '2026-06-03', // 지방선거일
            '2026-08-17', // 광복절 (대체)
            '2026-09-24', // 추석 연휴
            '2026-09-25', // 추석
            '2026-10-05', // 개천절 (대체)
            '2026-10-09', // 한글날
            '2026-12-25'  // 성탄절
        ]);

        // [V7] 로컬 시간 기준 YYYY-MM-DD 반환 헬퍼 함수
        function getLocalDateString(date) {
            const year = date.getFullYear();
            const month = (date.getMonth() + 1).toString().padStart(2, '0');
            const day = date.getDate().toString().padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        // [V5] 날짜가 휴일(주말+공휴일)인지 확인하는 함수
        function isHoliday(date, holidaySet) {
            const day = date.getDay();
            // 0: 일요일, 6: 토요일
            if (day === 0 || day === 6) {
                return true;
            }
            // YYYY-MM-DD 형식의 문자열로 변환 (V7 - 로컬 시간 기준)
            const dateString = getLocalDateString(date);
            if (holidaySet.has(dateString)) {
                return true;
            }
            return false;
        }

        // [V6] 동적 정렬 함수
        /**
         * @param {Array<Object>} availableDocs - 근무 가능한 의사 배열
         * @param {String} shiftType - 'HOLIDAY_DAY', 'HOLIDAY_NIGHT', 'WEEKDAY_DAY', 'WEEKDAY_NIGHT'
         * @returns {Array<Object>} 정렬된 의사 배열
         */
        function getSortedPool(availableDocs, shiftType) {
            availableDocs.sort((a, b) => {
                switch (shiftType) {
                    case 'HOLIDAY_DAY':
                        if (a.holidayDayShifts !== b.holidayDayShifts) return a.holidayDayShifts - b.holidayDayShifts;
                        if (a.totalHolidayShifts !== b.totalHolidayShifts) return a.totalHolidayShifts - b.totalHolidayShifts;
                        if (a.dayShifts !== b.dayShifts) return a.dayShifts - b.dayShifts;
                        if (a.totalShifts !== b.totalShifts) return a.totalShifts - b.totalShifts;
                        return a.lastShift - b.lastShift;
                    case 'HOLIDAY_NIGHT':
                        if (a.holidayNightShifts !== b.holidayNightShifts) return a.holidayNightShifts - b.holidayNightShifts;
                        if (a.totalHolidayShifts !== b.totalHolidayShifts) return a.totalHolidayShifts - b.totalHolidayShifts;
                        if (a.nightShifts !== b.nightShifts) return a.nightShifts - b.nightShifts;
                        if (a.totalShifts !== b.totalShifts) return a.totalShifts - b.totalShifts;
                        return a.lastShift - b.lastShift;
                    case 'WEEKDAY_DAY':
                        if (a.weekdayDayShifts !== b.weekdayDayShifts) return a.weekdayDayShifts - b.weekdayDayShifts;
                        if (a.totalWeekdayShifts !== b.totalWeekdayShifts) return a.totalWeekdayShifts - b.totalWeekdayShifts;
                        if (a.dayShifts !== b.dayShifts) return a.dayShifts - b.dayShifts;
                        if (a.totalShifts !== b.totalShifts) return a.totalShifts - b.totalShifts;
                        return a.lastShift - b.lastShift;
                    case 'WEEKDAY_NIGHT':
                        if (a.weekdayNightShifts !== b.weekdayNightShifts) return a.weekdayNightShifts - b.weekdayNightShifts;
                        if (a.totalWeekdayShifts !== b.totalWeekdayShifts) return a.totalWeekdayShifts - b.totalWeekdayShifts;
                        if (a.nightShifts !== b.nightShifts) return a.nightShifts - b.nightShifts;
                        if (a.totalShifts !== b.totalShifts) return a.totalShifts - b.totalShifts;
                        return a.lastShift - b.lastShift;
                }
            });
            return availableDocs;
        }

        document.addEventListener('DOMContentLoaded', () => {
            // 1. [V6] 의사 정보 객체 최종 확장
            let doctors = doctorsList.map(id => ({
                id: id,
                lastShift: 0,
                totalShifts: 0,
                dayShifts: 0,
                nightShifts: 0,
                totalHolidayShifts: 0,
                totalWeekdayShifts: 0,
                holidayDayShifts: 0,
                holidayNightShifts: 0,
                weekdayDayShifts: 0,
                weekdayNightShifts: 0
            }));

            let whoWorkedNightYesterday = []; // 전날 야간 근무자
            let currentShiftTime = 1; // 근무 시점을 기록할 가상 시간
            let partnerSelectionOffset = 1; // 파트너 순환용 오프셋

            // 1월 6일로 정확히 설정
            const startDate = new Date(year, 0, 6); 
            const endDate = new Date(year, 11, 31);

            for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
                const currentDate = new Date(d);
                // [V7] 로컬 시간 기준 문자열 사용
                const dateString = getLocalDateString(currentDate);
                const dayOfWeek = ['일', '월', '화', '수', '목', '금', '토'][currentDate.getDay()];
                
                const todayIsHoliday = isHoliday(currentDate, publicHolidays);
                
                // [V6] 근무 유형 정의
                const dayShiftType = todayIsHoliday ? 'HOLIDAY_DAY' : 'WEEKDAY_DAY';
                const nightShiftType = todayIsHoliday ? 'HOLIDAY_NIGHT' : 'WEEKDAY_NIGHT';

                // --- 주간 근무 배정 ---
                
                let dayPool = doctors.filter(doc => !whoWorkedNightYesterday.includes(doc.id));
                
                // [V6] 동적 정렬 적용
                dayPool = getSortedPool(dayPool, dayShiftType);

                let doc1_day = dayPool[0];
                let doc2_day_index = (partnerSelectionOffset % (dayPool.length - 1)) + 1;
                let doc2_day = dayPool[doc2_day_index];
                
                let dayShift = [doc1_day, doc2_day];
                partnerSelectionOffset++;
                
                const dayShiftIds = dayShift.map(d => d.id).sort();

                // [V6] 주간 근무 통계 상세 업데이트
                dayShiftIds.forEach(id => {
                    const docIndex = doctors.findIndex(d => d.id === id);
                    if(docIndex > -1) {
                        doctors[docIndex].lastShift = currentShiftTime;
                        doctors[docIndex].totalShifts++;
                        doctors[docIndex].dayShifts++;
                        if (todayIsHoliday) {
                            doctors[docIndex].totalHolidayShifts++;
                            doctors[docIndex].holidayDayShifts++;
                        } else {
                            doctors[docIndex].totalWeekdayShifts++;
                            doctors[docIndex].weekdayDayShifts++;
                        }
                    }
                });

                // --- 야간 근무 배정 ---

                let nightPool = doctors.filter(doc => !dayShiftIds.includes(doc.id));

                // [V6] 동적 정렬 적용
                nightPool = getSortedPool(nightPool, nightShiftType);

                let doc1_night = nightPool[0];
                let doc2_night_index = (partnerSelectionOffset % (nightPool.length - 1)) + 1;
                let doc2_night = nightPool[doc2_night_index];
                
                let nightShift = [doc1_night, doc2_night];
                partnerSelectionOffset++; 

                const nightShiftIds = nightShift.map(d => d.id).sort();

                // [V6] 야간 근무 통계 상세 업데이트
                nightShiftIds.forEach(id => {
                    const docIndex = doctors.findIndex(d => d.id === id);
                     if(docIndex > -1) {
                        doctors[docIndex].lastShift = currentShiftTime;
                        doctors[docIndex].totalShifts++;
                        doctors[docIndex].nightShifts++;
                        if (todayIsHoliday) {
                            doctors[docIndex].totalHolidayShifts++;
                            doctors[docIndex].holidayNightShifts++;
                        } else {
                            doctors[docIndex].totalWeekdayShifts++;
                            doctors[docIndex].weekdayNightShifts++;
                        }
                    }
                });

                // --- 전역 스케줄 변수에 저장 ---
                generatedSchedule.push({
                    date: dateString,
                    dayOfWeek: dayOfWeek,
                    day: dayShiftIds,
                    night: nightShiftIds,
                    isHoliday: todayIsHoliday
                });

                whoWorkedNightYesterday = [...nightShiftIds];
                currentShiftTime++;
            }

            // --- 결과 렌더링 ---
            renderTable(generatedSchedule);
            renderStats(doctors);

            // 버튼 이벤트 리스너 연결
            document.getElementById('export-csv-btn').addEventListener('click', exportToCSV);
        });

        // 테이블 렌더링 함수
        function renderTable(schedule) {
            const scheduleBody = document.getElementById('schedule-body');
            let tableHtml = '';
            schedule.forEach(item => {
                const rowClass = item.isHoliday ? 'bg-red-50' : ''; 
                tableHtml += `
                    <tr class="${rowClass}">
                        <td class="px-4 py-3 whitespace-nowrap text-sm font-medium text-gray-900">${item.date}</td>
                        <td class="px-4 py-3 whitespace-nowrap text-sm text-gray-500">${item.dayOfWeek}</td>
                        <td class="px-4 py-3 whitespace-nowrap text-sm font-semibold text-blue-600">${item.day.join(', ')}</td>
                        <td class="px-4 py-3 whitespace-nowrap text-sm font-semibold text-indigo-600">${item.night.join(', ')}</td>
                    </tr>
                `;
            });
            scheduleBody.innerHTML = tableHtml;
        }

        // [V6] 통계 렌더링 함수 (4대 유형, 순서 변경됨)
        function renderStats(doctors) {
            const statsDiv = document.getElementById('stats');
            let statsHtml = '';
            doctors.sort((a, b) => a.id.localeCompare(b.id)); // ID 순으로 정렬
            
            doctors.forEach(doc => {
                statsHtml += `
                    <div class="bg-gray-50 p-3 rounded-lg shadow-sm">
                        <div class="font-bold text-lg text-gray-800">${doc.id}</div>
                        <div class="text-sm text-gray-600 mt-1">
                            <div>
                                총: <span class="font-semibold text-black">${doc.totalShifts}</span>
                                (휴일: <span class="font-semibold text-red-600">${doc.totalHolidayShifts}</span>)
                            </div>
                            <div class="mt-1">
                                주간: <span class="font-semibold text-blue-600">${doc.dayShifts}</span>
                                <span class="text-xs">(평: ${doc.weekdayDayShifts}, 휴: ${doc.holidayDayShifts})</span>
                            </div>
                            <div class="mt-1">
                                야간: <span class="font-semibold text-indigo-600">${doc.nightShifts}</span>
                                <span class="text-xs">(평: ${doc.weekdayNightShifts}, 휴: ${doc.holidayNightShifts})</span>
                            </div>
                        </div>
                    </div>
                `;
            });
            statsDiv.innerHTML = statsHtml;
        }

        // CSV 내보내기 함수
        function exportToCSV() {
            if (generatedSchedule.length === 0) {
                console.log("No schedule data to export.");
                return;
            }

            let csvContent = "Date,DayOfWeek,DayWorker1,DayWorker2,NightWorker1,NightWorker2,IsHoliday\r\n";

            generatedSchedule.forEach(item => {
                const row = [
                    item.date,
                    item.dayOfWeek,
                    item.day[0],
                    item.day[1],
                    item.night[0],
                    item.night[1],
                    item.isHoliday ? 'H' : '' // 휴일인 경우 'H' 표시
                ].join(",");
                csvContent += row + "\r\n";
            });

            // BOM 추가 (Excel에서 한글 깨짐 방지)
            const BOM = "\uFEFF";
            const csvData = BOM + csvContent;

            // 파일 다운로드 로직
            const blob = new Blob([csvData], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);
            
            link.setAttribute("href", url);
            link.setAttribute("download", "2026_ER_Schedule_V7_Jan6_Fixed.csv"); // 파일명 변경
            link.style.visibility = 'hidden';
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

    </script>
</body>
</html>
